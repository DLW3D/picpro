"""
加载数据
"""
import os
import tensorflow as tf
import keras.backend.tensorflow_backend as KTF
from keras.preprocessing import image
from keras.preprocessing.image import ImageDataGenerator

# 手动分配GPU
config = tf.ConfigProto()
config.gpu_options.allow_growth = True  # 不全部占满显存, 按需分配
# config.gpu_options.per_process_gpu_memory_fraction = 0.5  # 指定分配50%空间
sess = tf.Session(config=config)  # 设置session
KTF.set_session(sess)

data_dir = r'C:\Users\78753\.keras\data\2faces\96'
latent_dim = 100
height = 96
width = 96
channels = 3
batch_size = 64

train_datagen = ImageDataGenerator(rescale=1./255)
train_generator = train_datagen.flow_from_directory(
    # 目标文件夹
    data_dir,
    # 规范化图片大小
    target_size=(height,width),
    batch_size=batch_size)


"""
生成器（generator）
首先，创建一个“生成器（generator）”模型，它将一个矢量（从潜在空间 - 在训练期间随机采样）转换为候选图像。
GAN通常出现的许多问题之一是generator卡在生成的图像上，看起来像噪声。一种可能的解决方案是在鉴别器（discriminator）
和生成器（generator）上使用dropout。
"""
import keras
from keras import layers
import numpy as np

kernel_init = keras.initializers.RandomNormal(stddev=0.02)


generator_input = keras.Input(shape=(latent_dim,))
# 100
generator = layers.Dense(6 * 6 * 512, activation='relu')(generator_input)
generator = layers.Reshape((6, 6, 512))(generator)
# 6*6*512
generator = layers.Conv2DTranspose(256, 5, strides=2, padding='same', kernel_initializer=kernel_init)(generator)
generator = layers.BatchNormalization(momentum=0.9)(generator)
generator = layers.ReLU()(generator)
# 12*12*256
generator = layers.Conv2DTranspose(128, 5, strides=2, padding='same', kernel_initializer=kernel_init)(generator)
generator = layers.BatchNormalization(momentum=0.9)(generator)
generator = layers.ReLU()(generator)
# 24*24*128
generator = layers.Conv2DTranspose(64, 5, strides=2, padding='same', kernel_initializer=kernel_init)(generator)
generator = layers.BatchNormalization(momentum=0.9)(generator)
generator = layers.ReLU()(generator)
# 48*48*64
generator = layers.Conv2DTranspose(3, 5, strides=2, padding='same', activation='tanh')(generator)
# 96*96*3
generator = keras.models.Model(generator_input, generator)
generator.summary()


'''
discriminator(鉴别器)
创建鉴别器模型，它将候选图像（真实的或合成的）作为输入，并将其分为两类：“生成的图像”或“来自训练集的真实图像”。
'''
discriminator_input = layers.Input(shape=(height, width, channels))
# 96
discriminator = layers.Conv2D(64, kernel_size=5, strides=2, padding='same', kernel_initializer=kernel_init)(discriminator_input)
discriminator = layers.LeakyReLU(alpha=0.2)(discriminator)
# 48
discriminator = layers.Conv2D(128, kernel_size=5, strides=2, padding='same', kernel_initializer=kernel_init)(discriminator)
discriminator = layers.BatchNormalization(momentum=0.9)(discriminator)
discriminator = layers.LeakyReLU(alpha=0.2)(discriminator)
# 24
discriminator = layers.Conv2D(256, kernel_size=5, strides=2, padding='same', kernel_initializer=kernel_init)(discriminator)
discriminator = layers.BatchNormalization(momentum=0.9)(discriminator)
discriminator = layers.LeakyReLU(alpha=0.2)(discriminator)
# 12
discriminator = layers.Conv2D(512, kernel_size=5, strides=2, padding='same', kernel_initializer=kernel_init)(discriminator)
discriminator = layers.BatchNormalization(momentum=0.9)(discriminator)
discriminator = layers.LeakyReLU(alpha=0.2)(discriminator)
# 6
discriminator = layers.Flatten()(discriminator)
# Output
discriminator = layers.Dense(1, activation='sigmoid')(discriminator)
discriminator = keras.models.Model(inputs=discriminator_input, outputs=discriminator, name='discriminator')
# prints a summary representation of your model
discriminator.summary()

discriminator_optimizer = keras.optimizers.Adam(lr=2e-4, beta_1=0.5)
discriminator.compile(optimizer=discriminator_optimizer, loss='binary_crossentropy')



'''
The adversarial network:对抗网络
最后，设置GAN，它链接生成器（generator）和鉴别器（discrimitor）。 这是一种模型，经过训练，
将使生成器（generator）朝着提高其愚弄鉴别器（discrimitor）能力的方向移动。 该模型将潜在的空间点转换为分类决策，
“假的”或“真实的”，并且意味着使用始终是“这些是真实图像”的标签来训练。 所以训练`gan`将以一种方式更新
“发生器”的权重，使得“鉴别器”在查看假图像时更可能预测“真实”。 非常重要的是，将鉴别器设置为在训练
期间被冻结（不可训练）：训练“gan”时其权重不会更新。 如果在此过程中可以更新鉴别器权重，那么将训练鉴别
器始终预测“真实”。
'''
# 将鉴别器（discrimitor）权重设置为不可训练（仅适用于`gan`模型）
discriminator.trainable = False

gan_input = keras.Input(shape=(latent_dim,))
gan_output = discriminator(generator(gan_input))
gan = keras.models.Model(gan_input, gan_output)

gan_optimizer = keras.optimizers.Adam(lr=2e-4, beta_1=0.5)
gan.compile(optimizer=gan_optimizer, loss='binary_crossentropy')



'''
  开始训练了。
  每个epoch：
   *在潜在空间中绘制随机点（随机噪声）。
   *使用此随机噪声生成带有“generator”的图像。
   *将生成的图像与实际图像混合。
   *使用这些混合图像训练“鉴别器”，使用相应的目标，“真实”（对于真实图像）或“假”（对于生成的图像）。
   *在潜在空间中绘制新的随机点。
   *使用这些随机向量训练“gan”，目标都是“这些是真实的图像”。 这将更新发生器的权重（仅因为鉴别器在“gan”内被冻结）
   以使它们朝向获得鉴别器以预测所生成图像的“这些是真实图像”，即这训练发生器欺骗鉴别器。
'''

epochs = 100
save_dir = '.\\gan_image'

# 开始训练迭代
for step in range(train_generator.samples // batch_size * epochs):
    # 在潜在空间中抽样随机点
    random_latent_vectors = np.random.normal(size=(batch_size, latent_dim))
    # 将随机抽样点解码为假图像
    generated_images = generator.predict(random_latent_vectors)
    # 将假图像与真实图像进行比较
    real_images = next(train_generator)[0]*2-1
    combined_images = np.concatenate([generated_images, real_images])
    # 组装区别真假图像的标签
    labels = np.concatenate([np.ones((generated_images.shape[0], 1)),
                             np.zeros((real_images.shape[0], 1))])
    # 重要的技巧，在标签上添加随机噪声
    # labels += 0.05 * np.random.random(labels.shape)
    # 训练鉴别器（discrimitor）
    discriminator.trainable = True
    d_loss = discriminator.train_on_batch(combined_images, labels)
    # ************************
    # 在潜在空间中采样随机点
    random_latent_vectors = np.random.normal(size=(batch_size, latent_dim))
    # 汇集标有“所有真实图像”的标签
    misleading_targets = np.zeros((batch_size, 1))
    # 训练生成器（generator）（通过gan模型，鉴别器（discrimitor）权值被冻结）
    discriminator.trainable = False
    a_loss = gan.train_on_batch(random_latent_vectors, misleading_targets)
    if step % (10) == 0:
        # 保存网络权值
        gan.save('gan.h5')
        # 输出metrics
        print('discriminator loss at step %s: %s' % (step, d_loss))
        print('adversarial loss at step %s: %s' % (step, a_loss))
        # 保存生成的图像
        img = image.array_to_img(generated_images[0]*127+127., scale=False)
        img.save(os.path.join(save_dir, 'generated_' + str(step) + '.png'))
        # 保存真实图像，以便进行比较
        img = image.array_to_img(real_images[0]*127+127., scale=False)
        img.save(os.path.join(save_dir, 'real_' + str(step) + '.png'))


# 绘图
import matplotlib.pyplot as plt

# 在潜在空间中抽样随机点
random_latent_vectors = np.random.normal(size=(10, latent_dim))

# 将随机抽样点解码为假图像
generated_images = generator.predict(random_latent_vectors)

for i in range(generated_images.shape[0]):
    img = image.array_to_img(generated_images[i] * 255., scale=False)
    plt.figure()
    plt.imshow(img)

plt.show()

